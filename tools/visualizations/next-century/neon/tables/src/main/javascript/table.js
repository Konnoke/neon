/*
 * ************************************************************************
 * Copyright (c), 2013 Next Century Corporation. All Rights Reserved.
 *
 * This software code is the exclusive property of Next Century Corporation and is
 * protected by United States and International laws relating to the protection
 * of intellectual property.  Distribution of this software code by or to an
 * unauthorized party, or removal of any of these notices, is strictly
 * prohibited and punishable by law.
 *
 * UNLESS PROVIDED OTHERWISE IN A LICENSE AGREEMENT GOVERNING THE USE OF THIS
 * SOFTWARE, TO WHICH YOU ARE AN AUTHORIZED PARTY, THIS SOFTWARE CODE HAS BEEN
 * ACQUIRED BY YOU "AS IS" AND WITHOUT WARRANTY OF ANY KIND.  ANY USE BY YOU OF
 * THIS SOFTWARE CODE IS AT YOUR OWN RISK.  ALL WARRANTIES OF ANY KIND, EITHER
 * EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE HEREBY EXPRESSLY
 * DISCLAIMED.
 *
 * PROPRIETARY AND CONFIDENTIAL TRADE SECRET MATERIAL NOT FOR DISCLOSURE OUTSIDE
 * OF NEXT CENTURY CORPORATION EXCEPT BY PRIOR WRITTEN PERMISSION AND WHEN
 * RECIPIENT IS UNDER OBLIGATION TO MAINTAIN SECRECY.
 */

var tables = tables || {};

/**
 * Creates a new table
 * @class Table
 * @namespace tables

 * @param {String} tableSelector The selector for the component in which the table will be drawn
 * @param {Object} opts A collection of key/value pairs used for configuration parameters:
 * <ul>
 *     <li>data (required) - An array of data to display in the table</li>
 *     <li>columns (optional) - A list of the fields to display in the table. If not specified, the table
 *     will iterate through all of the rows and get the unique column names. This can be a slow operation for
 *     large datasets.</li>
 *     <li>id (optional) - The name of the column with the unique id for the item. If this is not
 *     specified, an id field will be autogenerated and appended to the data (the original data
 *     will be modified)</li>
 * </ul>
 *
 * @constructor
 *
 * @example
 *     var data = [
 *                 {"field1": "aVa"l, "field2": 2},
 *                 {"field1": "bVal", "field2": 5, "anotherField" : "anotherVal"},
 *                ];
 *     var columns = ["field1","field2","anotherField"]
 *     var opts = { "data" : data, "columns" : columns };
 *     var table = new tables.Table('#table', opts).draw();
 * *
 */
tables.Table = function (tableSelector, opts) {
    this.tableSelector_ = tableSelector;
    this.idField_ = opts.id;
    var data = opts.data;
    var columns = opts.columns ? opts.columns : tables.Table.computeColumnNames_(data);

    if (!this.idField_) {
        tables.Table.appendGeneratedId_(data);
        this.idField_ = tables.Table.AUTOGENERATED_ID_FIELD_NAME_;
    }

    this.dataView_ = this.createDataView_(data);
    this.columns_ = tables.Table.createSlickgridColumns_(columns);
};

tables.Table.AUTOGENERATED_ID_FIELD_NAME_ = '__autogenerated_id';


/**
 * Computes the column names by iterating through the data and saving the unique column names.
 * @param {Array} data The data being shown in the table
 * @return {Array} The unique column names
 * @method computeColumnNames_
 * @private
 */
tables.Table.computeColumnNames_ = function (data) {
    // just use an object to store the keys for faster lookup (basically a hash where we don't care about the value)
    var columns = {};
    data.forEach(function (row) {
        var keys = Object.keys(row);
        keys.forEach(function (key) {
            columns[key] = true;
        });
    });
    return Object.keys(columns);
};

/**
 * Creates the sort comparator to sort the data in the table
 * @param {String} field The field being sorted
 * @param {Object} sortInfo Information provided by the data view about the sort operation
 * @return {Function} A function to perform the sort comparison
 * @method sortComparator_
 * @private
 */
tables.Table.sortComparator_ = function (field, sortInfo) {
    return function (a, b) {
        var result = 0;
        if (a[field] > b[field]) {
            result = 1;
        }
        else if (a[field] < b[field]) {
            result = -1;
        }
        return sortInfo.sortAsc ? result : -result;
    };
};

tables.Table.appendGeneratedId_ = function (data) {
    var id = 0;
    data.forEach(function (el) {
        el[tables.Table.AUTOGENERATED_ID_FIELD_NAME_] = id++;
    });
};

/**
 * Creates a slickgrid data view from the raw data
 * @param {Array} data Array of data to be displayed
 * @method createDataView_
 * @private
 */
tables.Table.prototype.createDataView_ = function (data) {
    var dataView = new Slick.Data.DataView();
    dataView.setItems(data, this.idField_);
    return dataView;
};


/**
 * Converts a list of column names to the format required by the slickgrids library
 * used to create the tables
 * @param {Array} columnNames A list of column names
 * @method createSlickgridColumns_
 * @private
 */
tables.Table.createSlickgridColumns_ = function (columnNames) {
    var slickgridColumns = [];
    columnNames.forEach(function (col) {
        var slickgridColumn = {};
        slickgridColumn.id = col;
        slickgridColumn.name = col;
        slickgridColumn.field = col;
        slickgridColumn.sortable = true;
        slickgridColumn.formatter = tables.Table.defaultCellFormatter_;
        slickgridColumns.push(slickgridColumn);
    });
    return slickgridColumns;
};

tables.Table.defaultCellFormatter_ = function (row, cell, value, columnDef, dataContext) {
    // most of this taken from slick.grid.js defaultFormatter but modified to support nested objects
    if (!value) {
        return "";
    }

    // check if nested object. if it is, append each of the key/value pairs
    var keys = tables.Table.getObjectKeys_(value);

    if (keys.length === 0) {
        return (value + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    return tables.Table.createKeyValuePairsString_(value, keys, row, cell, columnDef, dataContext);

};

tables.Table.getObjectKeys_ = function (object) {
    var keys = [];
    if (typeof object === 'object') {
        keys = Object.keys(object);
    }
    return keys;
};

tables.Table.createKeyValuePairsString_ = function (object, keys, row, cell, columnDef, dataContext) {
    var keyValueStrings = [];
    keys.forEach(function (key) {
        keyValueStrings.push(key + ': ' + tables.Table.defaultCellFormatter_(row, cell, object[key], columnDef, dataContext));
    });
    return keyValueStrings.join(', ');
};

/**
 * Draws the table in the selector specified in the constructor
 * @method draw
 * @return {tables.Table} This table
 */
tables.Table.prototype.draw = function () {
    this.table_ = new Slick.Grid(this.tableSelector_, this.dataView_, this.columns_);
    this.addSortSupport_();
    this.table_.registerPlugin(new Slick.AutoTooltips({ enableForHeaderCells: true }));
    return this;
};


tables.Table.prototype.addSortSupport_ = function () {
    var me = this;
    this.table_.onSort.subscribe(function (event, args) {
        var field = args.sortCol.field;
        var data = me.dataView_.getItems();
        // use a stable sorting algorithm as opposed to the built-in
        // dataView sort which may not be stable
        data = data.mergeSort(tables.Table.sortComparator_(field, args));
        me.dataView_.setItems(data);
        me.table_.invalidateAllRows();
        me.table_.render();
    });
};