import org.apache.tools.ant.taskdefs.condition.Os
import org.apache.tools.ant.filters.ReplaceTokens
import com.ncc.neon.JasmineIncludesGenerator

defaultTasks 'clean', 'build'

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.eriwen:gradle-js-plugin:1.1'
    }
}

repositories {
    mavenCentral()
}

// task groupings we add
def DEPLOY_GROUP = 'deploy'

def owfTomcat = (hasProperty('OWF_TOMCAT') ? OWF_TOMCAT : System.env.OWF_TOMCAT) ?: '/opt/owf/apache-tomcat-7.0.21'
def owfTomcatWebapps = owfTomcat + '/webapps'

subprojects {

    apply plugin: 'war'
    apply plugin: 'js'
    apply plugin: 'idea'
    apply plugin: 'jetty'

    version = '1.0-SNAPSHOT'

    project.ext {
        jsdocDir = "${project.docsDir}/jsdocs"
        javadocDir = "${project.docsDir}/javadocs"
        libraryName = "$archivesBaseName-${project.version}"
        phantomJsRunner = "${rootDir}/js-test-support/lib/phantomjs-jasmine/run_jasmine_test.coffee"
    }


    jshint {
        dest = file("${buildDir}/jshint.out")
        doLast {
            def results = dest.text
            if (!results.isEmpty()) {
                def builder = new StringBuilder();
                builder.append("JSHint failed with errors. See output at ")
                        .append(dest.path)
                        .append(System.properties['line.separator'])
                        .append(System.properties['line.separator'])
                        .append(results)
                throw new GradleException(builder.toString())
            }
        }
    }

    war {
        description = 'Creates a war file for the project'

        // strip out the version from the war
        version ""
    }


    task deployToTomcat {
        dependsOn 'war'
        description = "Copies the project's war file to the owf tomcat webapps dir"
        group = DEPLOY_GROUP
        doLast {
            println "Copying $war.archivePath into $owfTomcatWebapps"
            copy {
                from war.archivePath
                into owfTomcatWebapps
            }
        }
    }


    task jsDocs(type: Exec) {
        description = 'Creates the javascript API documentation. This requires yuidocjs (minimum version 0.3.38) to be installed'
        group = JavaBasePlugin.DOCUMENTATION_GROUP

        // replace the tokens in the yuidoc descriptor file
        doFirst {
            new File(jsdocDir).mkdirs()
            copy {
                includeEmptyDirs = false
                from("${rootDir}/yuidoc") {
                    include('**/*.json')
                    // replace the tokens in the yuidoc file and put it in a temp dir so the yuidoc task can access it.
                    // this file is not part of the final docs output
                    filter(ReplaceTokens, tokens: [
                            projectDir: projectDir.absolutePath,
                            libraryName: libraryName.toString(),
                            outDir: jsdocDir.toString()
                    ]
                    )
                }
                into temporaryDir
            }
        }
        commandLine "yuidoc", "-c", "$temporaryDir/yuidoc.json"

        // copy the images after the yuidoc tasks runs because the yuidoc task will delete the output directory
        // these files are needed for the final docs output since they will be referenced in the html output
        doLast {
            copy {
                from("${rootDir}/yuidoc") {
                    include('images/*')
                }
                into jsdocDir
            }
        }
    }

    task copyJsDocs(type: org.gradle.api.tasks.Copy) {
        description = 'Copies the javascript documentation to a directory to be zipped'
        dependsOn 'jsDocs'
        doCopyDocsIntoZipDir('javascript-api-docs', libraryName, copyJsDocs, jsdocDir)
    }

    task zipJsDocs(type: Zip) {
        description = 'Creates a zip file containing the javascript API documentation'
        group = JavaBasePlugin.DOCUMENTATION_GROUP
        dependsOn 'copyJsDocs'
        doZipDocs(copyJsDocs, zipJsDocs, project.buildDir)
    }

}


/**
 * Configures the zip task to create a zip the documentation generated by the docs task
 * @param copyDocsTask
 * @param zipTask
 * @param buildDir
 */
def doZipDocs(copyDocsTask, zipTask, buildDir) {
    zipTask.from new File(copyDocsTask.zipDir).parent
    zipTask.destinationDir buildDir
    zipTask.archiveName "${copyDocsTask.zipBaseName}.zip"
}


/**
 * Configures a copy task to copy documentation into another directory for zipping
 * @param classifier A string appended to the doc zip file name (e.g. javadoc)
 * @param libraryName The name of the library whose docs are being created
 * @param copyTask The task being configured for copying
 * @param docDir The directory containing the documentation to be zipped
 */
def doCopyDocsIntoZipDir(classifier, libraryName, copyTask, docDir) {
    copyTask.ext.zipBaseName = "$libraryName-$classifier"

    // the zipDir is another directory with the same name as the zip file
    // used as the top level directory in the zip
    copyTask.ext.zipDir = "${copyTask.temporaryDir}/$copyTask.zipBaseName"

    copyTask.doFirst {
        new File(zipDir).mkdirs()
    }

    copyTask.from new File(docDir).path
    copyTask.into copyTask.zipDir

}

def doCreateJasmineSpec(subprojectDir, testDir, templateSuffix, scriptPath) {
    def templateFile = 'spec_runner.template.html'

    def scriptIncludes = new StringBuilder()

    def includesGenerator = new JasmineIncludesGenerator()
    includesGenerator.generateIncludes(subprojectDir, testDir)
    includesGenerator.matchingFiles.each { scriptIncludes.append('  <script src="').append(it).append('"></script>').append(System.properties['line.separator']) }
    def specRunnerOut = templateFile.replace('.template', "_${templateSuffix}")
    new File(new File(subprojectDir,testDir), specRunnerOut).delete()
    copy {
        from("${subprojectDir}/src/js-test-support") {
            filter(ReplaceTokens, tokens: [
                    includes: scriptIncludes.toString(),
                    script : scriptPath.toString()
            ])
            include(templateFile)
        }
        into new File(subprojectDir,testDir).toString()
        rename { String filename ->
            // only one file, so just return the new name
            specRunnerOut
        }
    }
}
