import com.mongodb.BasicDBObject
import com.mongodb.MongoClient
import com.mongodb.util.JSON
import com.ncc.neon.JasmineIncludesGenerator
import com.ncc.neon.MongoJSONGenerator
import org.apache.tools.ant.filters.ReplaceTokens

apply plugin: 'groovy'
apply plugin: 'codenarc'
apply plugin: 'jdepend'

archivesBaseName = 'neon'
sourceCompatibility = 1.7

def TEST_GROUP = JavaBasePlugin.VERIFICATION_GROUP
def springVersion = "3.2.1.RELEASE"
def logbackVersion = "1.0.9"

buildscript {
    repositories {
        mavenCentral()
        maven {
            url 'http://repository.codehaus.org/'
        }
    }
    dependencies {
        classpath 'org.mongodb:mongo-java-driver:2.10.1'
    }
}

repositories {
    maven {
        url 'https://repository.cloudera.com/artifactory/public'
    }
}

// properties defined in here are available in tasks and helper methods as
// properties of the project
project.ext {
    jsSrcDir = "src/main/javascript"
    jsUnitTestDir = "src/test/javascript"
    jsAcceptanceTestDir = "src/acceptanceTest/javascript"
    testDataDir = "${projectDir}/src/test-data"
    jsdocDir = "${project.docsDir}/jsdocs"
    javadocDir = "${project.docsDir}/javadocs"
    libraryName = "$archivesBaseName-${project.version}"
    javadocTitle = "$libraryName API Documentation"
    phantomJsRunner = "${projectDir}/src/js-test-support/lib/phantomjs-jasmine/run_jasmine_test.coffee"

    // a mongo instance for inserting/deleting test data (will be lazy initialized)
    mongoInstance = null

}


javascript.source {
    dev {
        js {
            srcDir jsSrcDir
            include "**/*.js"
            // the excluded files are added individually since their ordering matters relative to other files
            exclude 'intro.js'
            exclude 'outro.js'
            exclude 'util/loggerUtils.js'
        }
    }
    test {
        js {
            srcDir jsUnitTestDir
            srcDir jsAcceptanceTestDir
            include "**/*.js"
        }
    }
    lib {
        js {
            srcDir 'src/main/js-lib'
            include "**/*.js"
        }
    }

}

sourceSets {
    // contains the server integration tests
    integrationTest {
        resources {
            srcDir 'src/integrationTest/resources'
            srcDir 'src/test-data'
        }
    }

    acceptanceTest
}

configurations {
    integrationTestCompile { extendsFrom testCompile }
    integrationTestRuntime { extendsFrom integrationTestCompile, testRuntime }

    acceptanceTestCompile { extendsFrom testCompile }
    acceptanceTestRuntime { extendsFrom testCompile, testRuntime }

}

dependencies {
    groovy 'org.codehaus.groovy:groovy-all:2.0.5'

    compile 'com.sun.jersey:jersey-servlet:1.15'
    compile 'com.sun.jersey:jersey-core:1.15'
    compile 'com.sun.jersey:jersey-client:1.15'
    compile 'com.sun.jersey:jersey-server:1.15'
    compile 'com.sun.jersey:jersey-json:1.15'
    compile 'com.sun.jersey.contribs:jersey-spring:1.15'
    compile 'org.mongodb:mongo-java-driver:2.10.1'
    compile "org.springframework:spring-web:$springVersion"
    compile 'joda-time:joda-time:2.1'
    compile 'org.slf4j:slf4j-api:1.7.2'
    compile "ch.qos.logback:logback-core:$logbackVersion"
    compile "ch.qos.logback:logback-classic:$logbackVersion"
    compile "com.google.guava:guava:14.0.1"
    compile ('org.codehaus.groovy.modules.http-builder:http-builder:0.6') {
        // we already include groovy-all - this prevents bringing groovy in twice
        exclude module: 'groovy'
    }
    compile 'commons-lang:commons-lang:2.6'
    compile 'org.json:json:20090211'
    compile 'org.apache.hive:hive-jdbc:0.10.0-cdh4.2.1'
    compile 'org.apache.hadoop:hadoop-core:2.0.0-mr1-cdh4.2.1'

    providedCompile 'javax.servlet:javax.servlet-api:3.0.1'

    runtime 'cglib:cglib:2.2.2'

    testCompile 'junit:junit:4.11'
    testCompile 'commons-collections:commons-collections:3.2.1'
    testCompile 'commons-io:commons-io:2.4'
    testCompile "org.springframework:spring-test:$springVersion"

    integrationTestCompile files(sourceSets.main.output.classesDir)
    integrationTestCompile files(sourceSets.test.output.classesDir)


    codenarc "org.codenarc:CodeNarc:0.18.1"
}

// configure codenarc for each of the source sets
sourceSets.each { sourceSet ->
    def name = sourceSet.name
    // this set should only have one element for each source set
    def codenarcTasks = project.getTasksByName("codenarc${name.capitalize()}", false)
    codenarcTasks.each { task ->
        task.reports.xml.enabled = true
        task.reports.html.enabled = true
    }
}

jdepend {
    sourceSets = [sourceSets.main]
}

jdependMain.doLast {
    File file = new File(jdepend.reportsDir, "main.xml");
    def cycleCount = new XmlSlurper().parse(file).Cycles.Package.size()
    if (cycleCount > 0) {
        throw new GradleException("Package cycles exist. See JDepend report at ${file}")
    }
}

war {
    dependsOn 'jshint', 'combineJs', 'check'

    // add flags for the javascript and mongo integration tests since they require external software to be
    // installed (nodejs/phantomjs, mongo). turning these off by default makes it easy for people to build the war
    // even if they don't have them installed
    if (isRunJavascriptTests()) {
        dependsOn 'jsPhantomUnitTest'
    }
    if (isRunIntegrationTests()) {
        dependsOn 'integrationTests'
    }

    from("${buildDir}/${archivesBaseName}.js") {
        into 'js'
    }

    // strip out the version from the war
    version ""
}

test {
    def props = [:]
    props['unit.test'] = true
    systemProperties props
}


def isRunJavascriptTests() {
    return hasProperty('jsUnitTest')
}

def isRunIntegrationTests() {
    return hasProperty('integrationTest')
}

task integrationTests(type: Test) {
    dependsOn 'integrationTestClasses', 'generateMongoJson'

    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath

    def props = [:]
    def mongoHostProperty = getMongoHosts()
    if (mongoHostProperty) {
        props["mongo.hosts"] = mongoHostProperty
    }

    props['integration.test'] = true
    systemProperties props

}

task transformTestWebService(type: org.gradle.api.plugins.jetty.JettyRun) {
    dependsOn 'acceptanceTestClasses'
    daemon = true
    httpPort = 10008
    stopPort = httpPort + 2
    stopKey = 'stop'
    classpath = sourceSets.acceptanceTest.runtimeClasspath
    webXml = new File(sourceSets.acceptanceTest.output.resourcesDir, 'test-services-web.xml')
}

task acceptanceTestWar(type: org.gradle.api.plugins.jetty.JettyRunWar) {
    dependsOn 'acceptanceTestClasses'
    daemon = true
    httpPort = 10002
    stopPort = httpPort + 2
    stopKey = 'stop'
    jettyConfig = new File(sourceSets.acceptanceTest.output.resourcesDir, 'jetty-config.xml')
}

processAcceptanceTestResources {
    from(sourceSets.acceptanceTest.resources.srcDirs) {
        filter(ReplaceTokens, tokens: [
                "mongo.hosts": getMongoHosts()
        ])
    }
}

def getMongoHosts() {
    return project.hasProperty("mongo.hosts") ? getProperty("mongo.hosts") : "localhost"
}

task jsPhantomUnitTest(type: Exec) {
    dependsOn 'createJasmineUnitSpecRunnerHtml'
    group = TEST_GROUP
    description = 'Runs the Jasmine unit test suite using phantomjs (requires phantomjs to be installed and on path)'
    commandLine "phantomjs", phantomJsRunner, "${projectDir}/${jsUnitTestDir}/spec_runner_unit.html"
}


task jsPhantomAcceptanceTest(type: Exec) {
    dependsOn 'createJasmineAcceptanceSpecRunnerHtml', 'acceptanceTestWar', 'generateMongoJson', 'transformTestWebService'
    group = TEST_GROUP
    description = 'Runs the Jasmine acceptance test suite using phantomjs (requires phantomjs to be installed and on path)'
    // disable websecurity so we can make the ajax calls to the neon server
    doFirst {
        // just in case any data got left around in the event that a cleanup failed, delete the data before inserting it
        deleteAcceptanceTestData()
        insertAcceptanceTestData()
    }
    commandLine "phantomjs", "--web-security=no", phantomJsRunner, "${projectDir}/${jsAcceptanceTestDir}/spec_runner_acceptance.html"
}


gradle.taskGraph.afterTask { task ->
    if (task == jsPhantomAcceptanceTest) {
        deleteAcceptanceTestData()
    }
}

task generateMongoJson {
    MongoJSONGenerator.generateMongoJson(testDataDir, "${testDataDir}/mongo-json")
}


def insertAcceptanceTestData() {
    def db = getMongo().getDB("acceptanceTest")
    def collection = db.getCollection("records")
    def dbList = JSON.parse(new File(testDataDir, '/mongo-json/data.json').text)
    collection.insert(dbList)
    collection.ensureIndex(new BasicDBObject("location", "2dsphere"))
}

def deleteAcceptanceTestData() {
    def db = getMongo().getDB("acceptanceTest")
    db.dropDatabase()
}

def getMongo() {
    if (!mongoInstance) {
        mongoInstance = new MongoClient(getMongoHosts())
    }
    return mongoInstance
}

task createJasmineUnitSpecRunnerHtml << {
    description = 'Creates the jasmine spec runner html file for javascript unit tests'
    group = TEST_GROUP
    doCreateJasmineSpec(jsUnitTestDir, 'unit', '../../../build')
}

task createJasmineAcceptanceSpecRunnerHtml << {
    description = 'Creates the jasmine spec runner html file for javascript acceptance tests'
    group = TEST_GROUP
    doCreateJasmineSpec(jsAcceptanceTestDir, 'acceptance', "http://localhost:${acceptanceTestWar.httpPort}/neon/js")
}


def doCreateJasmineSpec(testDir, templateSuffix, neonJsPath) {
    def templateFile = 'spec_runner.template.html'

    def scriptIncludes = new StringBuilder()

    def includesGenerator = new JasmineIncludesGenerator()
    includesGenerator.generateIncludes(projectDir, testDir)
    includesGenerator.matchingFiles.each { scriptIncludes.append('  <script src="').append(it).append('"></script>').append(System.properties['line.separator']) }
    def specRunnerOut = templateFile.replace('.template', "_${templateSuffix}")
    new File(testDir, specRunnerOut).delete()
    copy {
        from('src/js-test-support') {
            filter(ReplaceTokens, tokens: [
                    includes: scriptIncludes.toString(),
                    "neonjs.path": neonJsPath.toString()
            ])
            include(templateFile)
        }
        into testDir
        rename { String filename ->
            // only one file, so just return the new name
            specRunnerOut
        }
    }
}

combineJs {
    source = javascript.source.lib.js.files +
            file("${jsSrcDir}/intro.js") +
            file("${jsSrcDir}/util/loggerUtils.js") +
            javascript.source.dev.js.files +
            file("${jsSrcDir}/outro.js")
    dest = file("${buildDir}/${archivesBaseName}.js")
}

minifyJs {
    source = combineJs
    dest = file("${buildDir}/${archivesBaseName}-min.js")
    closure {
        warningLevel = 'QUIET'
    }
}

jshint {
    source = javascript.source.dev.js.files + javascript.source.test.js.files
}


task jsDocs(type: Exec) {
    description = 'Creates the javascript API documentation. This requires yuidocjs (minimum version 0.3.38) to be installed'
    group = JavaBasePlugin.DOCUMENTATION_GROUP

    // replace the tokens in the yuidoc descriptor file
    doFirst {
        new File(jsdocDir).mkdirs()
        copy {
            includeEmptyDirs = false
            from('yuidoc') {
                include('**/*.json')
                // replace the tokens in the yuidoc file and put it in a temp dir so the yuidoc task can access it.
                // this file is not part of the final docs output
                filter(ReplaceTokens, tokens: [
                        projectDir: projectDir.absolutePath,
                        libraryName: libraryName.toString(),
                        outDir: jsdocDir.toString()
                ]
                )
            }
            into temporaryDir
        }
    }
    commandLine "yuidoc", "-c", "$temporaryDir/yuidoc.json"

    // copy the images after the yuidoc tasks runs because the yuidoc task will delete the output directory
    // these files are needed for the final docs output since they will be referenced in the html output
    doLast {
        copy {
            from('yuidoc') {
                include('images/*')
            }
            into jsdocDir
        }
    }
}

task copyJsDocs(type: org.gradle.api.tasks.Copy) {
    description = 'Copies the javascript documentation to a directory to be zipped'
    dependsOn 'jsDocs'
    doCopyDocsIntoZipDir('javascript-api-docs', copyJsDocs, jsdocDir)
}

groovydoc {
    destinationDir = file(javadocDir)
    docTitle = javadocTitle
    windowTitle = javadocTitle
}

task copyJavadocs(type: org.gradle.api.tasks.Copy) {
    description = 'Copies the javadocs to a directory to be zipped'
    dependsOn 'groovydoc'
    doCopyDocsIntoZipDir('javadocs', copyJavadocs, javadocDir)
}

/**
 * Configures a copy task to copy documentation into another directory for zipping
 * @param classifier A string appended to the doc zip file name (e.g. javadoc)
 * @param copyTask The task being configured for copying
 * @param docDir The directory containing the documentation to be zipped
 */
def doCopyDocsIntoZipDir(classifier, copyTask, docDir) {
    copyTask.ext.zipBaseName = "$libraryName-$classifier"

    // the zipDir is another directory with the same name as the zip file
    // used as the top level directory in the zip
    copyTask.ext.zipDir = "${copyTask.temporaryDir}/$copyTask.zipBaseName"

    copyTask.doFirst {
        new File(zipDir).mkdirs()
    }

    copyTask.from new File(docDir).path
    copyTask.into copyTask.zipDir

}


task zipJsDocs(type: Zip) {
    description = 'Creates a zip file containing the javascript API documentation'
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    dependsOn 'copyJsDocs'
    doZipDocs(copyJsDocs, zipJsDocs)
}

task zipJavadocs(type: Zip) {
    description = 'Creates a zip file containing the javadocs'
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    dependsOn 'copyJavadocs'
    doZipDocs(copyJavadocs, zipJavadocs)
}

/**
 * Configures the zip task to create a zip the documentation generated by the docs task
 * @param copyDocsTask
 * @param zipTask
 */
def doZipDocs(copyDocsTask, zipTask) {
    zipTask.from new File(copyDocsTask.zipDir).parent
    zipTask.destinationDir buildDir
    zipTask.archiveName "${copyDocsTask.zipBaseName}.zip"
}
